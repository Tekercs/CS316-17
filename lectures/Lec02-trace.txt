GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
Prelude> 2+2
4
Prelude> 2-2
0
Prelude> :info Bool
data Bool = False | True 	-- Defined in â€˜GHC.Typesâ€™
instance Bounded Bool -- Defined in â€˜GHC.Enumâ€™
instance Enum Bool -- Defined in â€˜GHC.Enumâ€™
instance Eq Bool -- Defined in â€˜GHC.Classesâ€™
instance Ord Bool -- Defined in â€˜GHC.Classesâ€™
instance Read Bool -- Defined in â€˜GHC.Readâ€™
instance Show Bool -- Defined in â€˜GHC.Showâ€™
Prelude> False
False
Prelude> True
True
Prelude> :type False
False :: Bool
Prelude> if True then 1 else 2
1
Prelude> if True then 1 else False

<interactive>:9:14:
    No instance for (Num Bool) arising from the literal â€˜1â€™
    In the expression: 1
    In the expression: if True then 1 else False
    In an equation for â€˜itâ€™: it = if True then 1 else False
Prelude> if True then "Hello" else False

<interactive>:10:27:
    Couldn't match expected type â€˜[Char]â€™ with actual type â€˜Boolâ€™
    In the expression: False
    In the expression: if True then "Hello" else False
Prelude> if False then 1 else 2
2
Prelude> :info Bool
data Bool = False | True 	-- Defined in â€˜GHC.Typesâ€™
instance Bounded Bool -- Defined in â€˜GHC.Enumâ€™
instance Enum Bool -- Defined in â€˜GHC.Enumâ€™
instance Eq Bool -- Defined in â€˜GHC.Classesâ€™
instance Ord Bool -- Defined in â€˜GHC.Classesâ€™
instance Read Bool -- Defined in â€˜GHC.Readâ€™
instance Show Bool -- Defined in â€˜GHC.Showâ€™
Prelude> :info Integer
data Integer
  = integer-gmp-1.0.0.0:GHC.Integer.Type.S# !GHC.Prim.Int#
  | integer-gmp-1.0.0.0:GHC.Integer.Type.Jp# {-# UNPACK #-}integer-gmp-1.0.0.0:GHC.Integer.Type.BigNat
  | integer-gmp-1.0.0.0:GHC.Integer.Type.Jn# {-# UNPACK #-}integer-gmp-1.0.0.0:GHC.Integer.Type.BigNat
  	-- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Enum Integer -- Defined in â€˜GHC.Enumâ€™
instance Eq Integer
  -- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Integral Integer -- Defined in â€˜GHC.Realâ€™
instance Num Integer -- Defined in â€˜GHC.Numâ€™
instance Ord Integer
  -- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Read Integer -- Defined in â€˜GHC.Readâ€™
instance Real Integer -- Defined in â€˜GHC.Realâ€™
instance Show Integer -- Defined in â€˜GHC.Showâ€™
Prelude> 
Prelude> 
Prelude> :info Integer
data Integer
  = integer-gmp-1.0.0.0:GHC.Integer.Type.S# !GHC.Prim.Int#
  | integer-gmp-1.0.0.0:GHC.Integer.Type.Jp# {-# UNPACK #-}integer-gmp-1.0.0.0:GHC.Integer.Type.BigNat
  | integer-gmp-1.0.0.0:GHC.Integer.Type.Jn# {-# UNPACK #-}integer-gmp-1.0.0.0:GHC.Integer.Type.BigNat
  	-- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Enum Integer -- Defined in â€˜GHC.Enumâ€™
instance Eq Integer
  -- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Integral Integer -- Defined in â€˜GHC.Realâ€™
instance Num Integer -- Defined in â€˜GHC.Numâ€™
instance Ord Integer
  -- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Read Integer -- Defined in â€˜GHC.Readâ€™
instance Real Integer -- Defined in â€˜GHC.Realâ€™
instance Show Integer -- Defined in â€˜GHC.Showâ€™
Prelude> 7
7
Prelude> :info Int
data Int = GHC.Types.I# GHC.Prim.Int# 	-- Defined in â€˜GHC.Typesâ€™
instance Bounded Int -- Defined in â€˜GHC.Enumâ€™
instance Enum Int -- Defined in â€˜GHC.Enumâ€™
instance Eq Int -- Defined in â€˜GHC.Classesâ€™
instance Integral Int -- Defined in â€˜GHC.Realâ€™
instance Num Int -- Defined in â€˜GHC.Numâ€™
instance Ord Int -- Defined in â€˜GHC.Classesâ€™
instance Read Int -- Defined in â€˜GHC.Readâ€™
instance Real Int -- Defined in â€˜GHC.Realâ€™
instance Show Int -- Defined in â€˜GHC.Showâ€™
Prelude> 9999999999999999999999999999999999999999999999999999999999999999 :: Integer
9999999999999999999999999999999999999999999999999999999999999999
Prelude> 9999999999999999999999999999999999999999999999999999999999999999 :: Int

<interactive>:18:1: Warning:
    Literal 9999999999999999999999999999999999999999999999999999999999999999 is out of the Int range -9223372036854775808..9223372036854775807
-1
Prelude> 2 * 10
20
Prelude> 2 ^ 10
1024
Prelude> 2 / 10
0.2
Prelude> (2 / 10) :: Integer

<interactive>:22:4:
    No instance for (Fractional Integer) arising from a use of â€˜/â€™
    In the expression: (2 / 10) :: Integer
    In an equation for â€˜itâ€™: it = (2 / 10) :: Integer
Prelude> div 2 10
0
Prelude> mod 2 10
2
Prelude> 2 `mod` 10
2
Prelude> 2 * 4
8
Prelude> (*) 2 4
8
Prelude> :info []
Prelude> :info []
data [] a = [] | a : [a] 	-- Defined in â€˜GHC.Typesâ€™
instance Eq a => Eq [a] -- Defined in â€˜GHC.Classesâ€™
instance Monad [] -- Defined in â€˜GHC.Baseâ€™
instance Functor [] -- Defined in â€˜GHC.Baseâ€™
instance Ord a => Ord [a] -- Defined in â€˜GHC.Classesâ€™
instance Read a => Read [a] -- Defined in â€˜GHC.Readâ€™
instance Show a => Show [a] -- Defined in â€˜GHC.Showâ€™
instance Applicative [] -- Defined in â€˜GHC.Baseâ€™
instance Foldable [] -- Defined in â€˜Data.Foldableâ€™
instance Traversable [] -- Defined in â€˜Data.Traversableâ€™
instance Monoid [a] -- Defined in â€˜GHC.Baseâ€™
Prelude> 1 : 2 : 3 : [] :: [Integer]
[1,2,3]
Prelude> [1,2,3]
[1,2,3]
Prelude> let hd (x:xs) = x
Prelude> hd [1,2,3[

<interactive>:32:11:
    parse error (possibly incorrect indentation or mismatched brackets)
Prelude> hd [1,2,3]
1
Prelude> hd [4,5,6]
4
Prelude> hd []
*** Exception: <interactive>:31:5-17: Non-exhaustive patterns in function hd

Prelude> let hd (x:xs) = x; hd [] = []
Prelude> :type hd
hd :: [[t]] -> [t]
Prelude> hd [1,2,3]

<interactive>:38:1:
    Non type-variable argument in the constraint: Num [t]
    (Use FlexibleContexts to permit this)
    When checking that â€˜itâ€™ has the inferred type
      it :: forall t. Num [t] => [t]
Prelude> :info Char
Prelude> :info Char
data Char = GHC.Types.C# GHC.Prim.Char# 	-- Defined in â€˜GHC.Typesâ€™
instance Bounded Char -- Defined in â€˜GHC.Enumâ€™
instance Enum Char -- Defined in â€˜GHC.Enumâ€™
instance Eq Char -- Defined in â€˜GHC.Classesâ€™
instance Ord Char -- Defined in â€˜GHC.Classesâ€™
instance Read Char -- Defined in â€˜GHC.Readâ€™
instance Show Char -- Defined in â€˜GHC.Showâ€™
Prelude> 'u'
'u'
Prelude> :type 'u'
'u' :: Char
Prelude> '\128515'
'\128515'
Prelude> putStrLn "\128515"
ðŸ˜ƒ
Prelude> :info String
type String = [Char] 	-- Defined in â€˜GHC.Baseâ€™
Prelude> hd "abc"

<interactive>:45:4:
    Couldn't match type â€˜Charâ€™ with â€˜[t]â€™
    Expected type: [[t]]
      Actual type: [Char]
    Relevant bindings include it :: [t] (bound at <interactive>:45:1)
    In the first argument of â€˜hdâ€™, namely â€˜"abc"â€™
    In the expression: hd "abc"
    In an equation for â€˜itâ€™: it = hd "abc"
Prelude> let hd (x:xs) = x
Prelude> hd "abc"
'a'
Prelude> :info (->)
data (->) a b 	-- Defined in â€˜GHC.Primâ€™
instance Monad ((->) r) -- Defined in â€˜GHC.Baseâ€™
instance Functor ((->) r) -- Defined in â€˜GHC.Baseâ€™
instance Applicative ((->) a) -- Defined in â€˜GHC.Baseâ€™
instance Monoid b => Monoid (a -> b) -- Defined in â€˜GHC.Baseâ€™
Prelude> :type hd
hd :: [t] -> t
Prelude> let f x = 2*x
Prelude> :t f
f :: Num a => a -> a
Prelude> :t (\x -> x)
(\x -> x) :: r -> r
Prelude> :info Num
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  	-- Defined in â€˜GHC.Numâ€™
instance Num Word -- Defined in â€˜GHC.Numâ€™
instance Num Integer -- Defined in â€˜GHC.Numâ€™
instance Num Int -- Defined in â€˜GHC.Numâ€™
instance Num Float -- Defined in â€˜GHC.Floatâ€™
instance Num Double -- Defined in â€˜GHC.Floatâ€™
Prelude> let f x = negate x
Prelude> :type f
f :: Num a => a -> a
Prelude> (1200000000000000000000000000000000000000000000000 :: Integer) + 12
1200000000000000000000000000000000000000000000012
Prelude> 12.084376843658743 + 0.438763846
12.523140689658744
Prelude> :info Double
data Double = GHC.Types.D# GHC.Prim.Double#
  	-- Defined in â€˜GHC.Typesâ€™
instance Enum Double -- Defined in â€˜GHC.Floatâ€™
instance Eq Double -- Defined in â€˜GHC.Classesâ€™
instance Floating Double -- Defined in â€˜GHC.Floatâ€™
instance Fractional Double -- Defined in â€˜GHC.Floatâ€™
instance Num Double -- Defined in â€˜GHC.Floatâ€™
instance Ord Double -- Defined in â€˜GHC.Classesâ€™
instance Read Double -- Defined in â€˜GHC.Readâ€™
instance Real Double -- Defined in â€˜GHC.Floatâ€™
instance RealFloat Double -- Defined in â€˜GHC.Floatâ€™
instance RealFrac Double -- Defined in â€˜GHC.Floatâ€™
instance Show Double -- Defined in â€˜GHC.Floatâ€™
Prelude> :info Eq
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  	-- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b) => Eq (Either a b)
  -- Defined in â€˜Data.Eitherâ€™
instance Eq a => Eq [a] -- Defined in â€˜GHC.Classesâ€™
instance Eq Word -- Defined in â€˜GHC.Classesâ€™
instance Eq Ordering -- Defined in â€˜GHC.Classesâ€™
instance Eq Int -- Defined in â€˜GHC.Classesâ€™
instance Eq Float -- Defined in â€˜GHC.Classesâ€™
instance Eq Double -- Defined in â€˜GHC.Classesâ€™
instance Eq Char -- Defined in â€˜GHC.Classesâ€™
instance Eq Bool -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n, Eq o) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j) =>
         Eq (a, b, c, d, e, f, g, h, i, j)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) =>
         Eq (a, b, c, d, e, f, g, h, i)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) =>
         Eq (a, b, c, d, e, f, g, h)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) =>
         Eq (a, b, c, d, e, f, g)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) =>
         Eq (a, b, c, d, e, f)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b, Eq c) => Eq (a, b, c)
  -- Defined in â€˜GHC.Classesâ€™
instance (Eq a, Eq b) => Eq (a, b) -- Defined in â€˜GHC.Classesâ€™
instance Eq () -- Defined in â€˜GHC.Classesâ€™
instance Eq Integer
  -- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Eq a => Eq (Maybe a) -- Defined in â€˜GHC.Baseâ€™
Prelude> let beginsWith a (b:bs) = a == b; beginsWith a [] = False
Prelude> beginsWith 5 [1,2,3,4]
False
Prelude> beginsWith 5 [5,1,2,3,4]
True
Prelude> beginsWith 'a' "hello"
False
Prelude> beginsWith 'a' "ahello"
True
Prelude> beginsWith not [(\x -> x), not]

<interactive>:65:1:
    No instance for (Eq (Bool -> Bool))
      (maybe you haven't applied enough arguments to a function?)
      arising from a use of â€˜beginsWithâ€™
    In the expression: beginsWith not [(\ x -> x), not]
    In an equation for â€˜itâ€™: it = beginsWith not [(\ x -> x), not]
Prelude> :type beginsWith
beginsWith :: Eq a => a -> [a] -> Bool
Prelude> :info 
Prelude> :info Ord
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  	-- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b) => Ord (Either a b)
  -- Defined in â€˜Data.Eitherâ€™
instance Ord a => Ord [a] -- Defined in â€˜GHC.Classesâ€™
instance Ord Word -- Defined in â€˜GHC.Classesâ€™
instance Ord Ordering -- Defined in â€˜GHC.Classesâ€™
instance Ord Int -- Defined in â€˜GHC.Classesâ€™
instance Ord Float -- Defined in â€˜GHC.Classesâ€™
instance Ord Double -- Defined in â€˜GHC.Classesâ€™
instance Ord Char -- Defined in â€˜GHC.Classesâ€™
instance Ord Bool -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j) =>
         Ord (a, b, c, d, e, f, g, h, i, j)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i) =>
         Ord (a, b, c, d, e, f, g, h, i)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g,
          Ord h) =>
         Ord (a, b, c, d, e, f, g, h)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) =>
         Ord (a, b, c, d, e, f, g)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) =>
         Ord (a, b, c, d, e, f)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d, e)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b) => Ord (a, b) -- Defined in â€˜GHC.Classesâ€™
instance Ord () -- Defined in â€˜GHC.Classesâ€™
instance Ord Integer
  -- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Ord a => Ord (Maybe a) -- Defined in â€˜GHC.Baseâ€™
Prelude> :info Ordering
data Ordering = LT | EQ | GT 	-- Defined in â€˜GHC.Typesâ€™
instance Bounded Ordering -- Defined in â€˜GHC.Enumâ€™
instance Enum Ordering -- Defined in â€˜GHC.Enumâ€™
instance Eq Ordering -- Defined in â€˜GHC.Classesâ€™
instance Ord Ordering -- Defined in â€˜GHC.Classesâ€™
instance Read Ordering -- Defined in â€˜GHC.Readâ€™
instance Show Ordering -- Defined in â€˜GHC.Showâ€™
instance Monoid Ordering -- Defined in â€˜GHC.Baseâ€™
Prelude> 
Prelude> :info Ord
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  	-- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b) => Ord (Either a b)
  -- Defined in â€˜Data.Eitherâ€™
instance Ord a => Ord [a] -- Defined in â€˜GHC.Classesâ€™
instance Ord Word -- Defined in â€˜GHC.Classesâ€™
instance Ord Ordering -- Defined in â€˜GHC.Classesâ€™
instance Ord Int -- Defined in â€˜GHC.Classesâ€™
instance Ord Float -- Defined in â€˜GHC.Classesâ€™
instance Ord Double -- Defined in â€˜GHC.Classesâ€™
instance Ord Char -- Defined in â€˜GHC.Classesâ€™
instance Ord Bool -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j) =>
         Ord (a, b, c, d, e, f, g, h, i, j)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i) =>
         Ord (a, b, c, d, e, f, g, h, i)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g,
          Ord h) =>
         Ord (a, b, c, d, e, f, g, h)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) =>
         Ord (a, b, c, d, e, f, g)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) =>
         Ord (a, b, c, d, e, f)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d, e)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b) => Ord (a, b) -- Defined in â€˜GHC.Classesâ€™
instance Ord () -- Defined in â€˜GHC.Classesâ€™
instance Ord Integer
  -- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Ord a => Ord (Maybe a) -- Defined in â€˜GHC.Baseâ€™
Prelude> 3 < 7
True
Prelude> (\ x -> x) < not

<interactive>:71:12:
    No instance for (Ord (Bool -> Bool))
      (maybe you haven't applied enough arguments to a function?)
      arising from a use of â€˜<â€™
    In the expression: (\ x -> x) < not
    In an equation for â€˜itâ€™: it = (\ x -> x) < not
Prelude> :info Ord
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  	-- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b) => Ord (Either a b)
  -- Defined in â€˜Data.Eitherâ€™
instance Ord a => Ord [a] -- Defined in â€˜GHC.Classesâ€™
instance Ord Word -- Defined in â€˜GHC.Classesâ€™
instance Ord Ordering -- Defined in â€˜GHC.Classesâ€™
instance Ord Int -- Defined in â€˜GHC.Classesâ€™
instance Ord Float -- Defined in â€˜GHC.Classesâ€™
instance Ord Double -- Defined in â€˜GHC.Classesâ€™
instance Ord Char -- Defined in â€˜GHC.Classesâ€™
instance Ord Bool -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j) =>
         Ord (a, b, c, d, e, f, g, h, i, j)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i) =>
         Ord (a, b, c, d, e, f, g, h, i)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g,
          Ord h) =>
         Ord (a, b, c, d, e, f, g, h)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) =>
         Ord (a, b, c, d, e, f, g)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) =>
         Ord (a, b, c, d, e, f)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d, e)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
  -- Defined in â€˜GHC.Classesâ€™
instance (Ord a, Ord b) => Ord (a, b) -- Defined in â€˜GHC.Classesâ€™
instance Ord () -- Defined in â€˜GHC.Classesâ€™
instance Ord Integer
  -- Defined in â€˜integer-gmp-1.0.0.0:GHC.Integer.Typeâ€™
instance Ord a => Ord (Maybe a) -- Defined in â€˜GHC.Baseâ€™
Prelude> :info Bool
data Bool = False | True 	-- Defined in â€˜GHC.Typesâ€™
instance Bounded Bool -- Defined in â€˜GHC.Enumâ€™
instance Enum Bool -- Defined in â€˜GHC.Enumâ€™
instance Eq Bool -- Defined in â€˜GHC.Classesâ€™
instance Ord Bool -- Defined in â€˜GHC.Classesâ€™
instance Read Bool -- Defined in â€˜GHC.Readâ€™
instance Show Bool -- Defined in â€˜GHC.Showâ€™
Prelude> True < False
False
Prelude> data MyType = MkMyType
Prelude> MkMyType < MkMyType

<interactive>:76:10:
    No instance for (Ord MyType) arising from a use of â€˜<â€™
    In the expression: MkMyType < MkMyType
    In an equation for â€˜itâ€™: it = MkMyType < MkMyType
Prelude> MkMyType == MkMyType

<interactive>:77:10:
    No instance for (Eq MyType) arising from a use of â€˜==â€™
    In the expression: MkMyType == MkMyType
    In an equation for â€˜itâ€™: it = MkMyType == MkMyType
Prelude> instance Eq MyType where x == y = True
Prelude> MkMyType == MkMyType
True
Prelude> \x -> x

<interactive>:80:1:
    No instance for (Show (t0 -> t0))
      (maybe you haven't applied enough arguments to a function?)
      arising from a use of â€˜printâ€™
    In a stmt of an interactive GHCi command: print it
Prelude> :info Bool
data Bool = False | True 	-- Defined in â€˜GHC.Typesâ€™
instance Bounded Bool -- Defined in â€˜GHC.Enumâ€™
instance Enum Bool -- Defined in â€˜GHC.Enumâ€™
instance Eq Bool -- Defined in â€˜GHC.Classesâ€™
instance Ord Bool -- Defined in â€˜GHC.Classesâ€™
instance Read Bool -- Defined in â€˜GHC.Readâ€™
instance Show Bool -- Defined in â€˜GHC.Showâ€™
Prelude> 
Leaving GHCi.
